"""
.cdif File Reader
Reads the Header Control Block and extended header of 
a .cdif file generated by SignalVu-PC
Author: Morgan Allison
Date edited: 11/17
Windows 7 64-bit
Python 3.6.1
NumPy 1.13.3
Tested with files generated by SignalVu-PC 3.11.0047
"""

import numpy as np

class MidasError(Exception):
    pass

class CDIF():
    def __init__(self, fileName):
        """Open .cdif file, read raw data, set up class members"""
        with open(fileName, 'rb') as f:
            self.raw = f.read()
        
        # empty dicts for header and extended header
        self.header = {}
        self.extHeader = {}
        
        # convert midas type codes to NumPy data types
        self.midas_to_np = {'O' : np.uint8, 'B' : np.int8, 
            'I' : np.int16, 'L' : np.int32, 'X' : np.int64, 
            'F' : np.float32, 'D' : np.float64}
        
        # not used yet
        self.midas_to_units = {'0': 'N/A', '1': 'sec time', '2': 'sec delay',
            '3': 'Hz freq', '4': 'time code', '5': 'm', '6': 'm/s', 
            '7': 'm/s^2', '8': 'm/s^3', '9': 'Hz doppler', '10': 'Hz/s^2',
            '11': 'J', '12': 'W', '13': 'g', '14': 'L', '15': 'W/sr',
            '16': 'W/rad', '17': 'W/m^2', '18': 'W/m', '19': 'W/MHz',
            '30': 'unknown', '31': 'dimensionless', '32': 'counts',
            '33': 'rad', '34': 'deg', '35': 'dB', '36': 'dBm', '38': 'sr',
            '41': 'nautical mi', '50': 'Hz ang vel', '52': 'rad/s ang vel',
            '54': 'rad/s^2 ang acc', '56': '%', '57': 'psi', '64': 'Hz/s^2',
            '65': 'Hz/s^3'}

    def build_header_control_block(self):    
        """Build a dict for the Header Control Block for cdif files
        based on Platinum Blue Data Exchange Format Standard, 
        Revision 4 Volume 1: Platinum Blue File Format, 16 June 2009"""
        """Fixed Header Control Block (HCB) defined in Section 2 Table 7"""
        self.header['version'] = self.raw[0:4].decode('latin_1')
        self.header['header_endian'] = self.raw[4:8].decode('latin_1')
        self.header['data_endian'] = self.raw[8:12].decode('latin_1')
        self.header['detached'] = np.fromstring(self.raw[12:16], dtype=np.uint32)[0]
        self.header['protected'] = np.fromstring(self.raw[16:20], dtype=np.uint32)[0]
        # ext_start is the 512-byte block number at which the extended header begins
        self.header['ext_start'] = np.fromstring(self.raw[24:28], dtype=np.uint32)[0]*512
        self.header['ext_size'] = np.fromstring(self.raw[28:32], dtype=np.uint32)[0]
        self.header['data_start'] = np.fromstring(self.raw[32:40], dtype=np.float64)[0]
        self.header['data_size'] = np.fromstring(self.raw[40:48], dtype=np.float64)[0]
        self.header['type_code'] = np.fromstring(self.raw[48:52], dtype=np.uint32)[0]
        self.header['data_format'] = self.raw[52:54].decode('latin_1')
        self.header['timecode'] = np.fromstring(self.raw[56:64], dtype=np.float64)[0]
        self.header['keylength'] = np.fromstring(self.raw[160:164], dtype=np.uint32)[0]
        self.header['keywords'] = self.raw[164:164+self.header['keylength']]

    def extended_header_kwd(self, idx):
        """Build a dict for a single cdif extended header keyword
        and append it to the .extHeader member of the CDIF class
        based on Platinum Blue Data Exchange Format Standard, 
        Revision 4 Volume 1: Platinum Blue File Format, 16 June 2009
        Extended Header defined in Section 2.7 Table 12
        Arguments: idx, the address at which to start parsing the current extended header keyword
        Returns: the address at which to start parsing the next extended header keyword"""
        kwd = {}
        try:
            kwd['next_offset'] = np.fromstring(self.raw[idx:idx+4], dtype=np.int32)[0]
        except IndexError:
            return
        kwd['non_data_length'] = np.fromstring(self.raw[idx+4:idx+6], dtype=np.int16)[0]
        kwd['name_length'] = self.raw[idx+6]
        
        dataStart = idx+8
        dataLength = dataStart+kwd['next_offset']-kwd['non_data_length']
        nameLength = dataLength+kwd['name_length']

        try:
            kwd['format_code'] = self.midas_to_np[chr(self.raw[idx+7])]
            kwd['data'] = np.fromstring(self.raw[dataStart:dataLength], dtype=kwd['format_code'])
        except KeyError:
            kwd['format_code'] = chr(self.raw[idx+7])
            if kwd['format_code'] != 'A':
                raise MidasError('Invalid Extended Header format_code.')
            else:
                kwd['data'] = self.raw[dataStart:dataLength].decode('latin_1')
                
        kwd['key_name'] = self.raw[dataLength:dataLength+kwd['name_length']].decode('latin_1')
        self.extHeader[kwd['key_name']] = kwd

        return idx+kwd['next_offset']

    def build_extended_header(self):
        nextStart = self.extended_header_kwd(self.header['ext_start'])
        while nextStart:
            nextStart = self.extended_header_kwd(nextStart)

    def build_data(self):
        dType = self.midas_to_np[self.header['data_format'][-1]]
        start = int(self.header['data_start'])
        stop = int(self.header['data_start']+self.header['data_size'])
        self.data = np.fromstring(self.raw[start:stop], dtype=dType)*
            self.extHeader['RSA_DATA_SCALE']['data']



def main():
    import matplotlib.pyplot as plt
    # enter your own file name in the argument of CDIF
    cdif = CDIF('C:\\SignalVu-PC Files\\abc-2017.11.20.16.35.55.434.cdif')
    
    cdif.build_header_control_block()
    cdif.build_extended_header()
    print(cdif.extHeader['ACQTIME']['data'])
    print(cdif.header)
    # for i in cdif.extHeader:
        # print(i)
    print(cdif.extHeader['RSA_DATA_SCALE'])

    cdif.build_data()

    plt.plot(cdif.data)
    plt.show()



if __name__ == '__main__':
    main()
